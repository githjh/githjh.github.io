---
layout: post
title: PoS vs PoW
categories: others
---

<h3> 초록 </h3>

지분 증명은 Bitcoin에서 사용되는 작업 증명의 대안인 디지털 화폐에 대한 합의 메커니즘이다. 스테이크 접근법을 증명하는 주요 장점은 값 비싼 계산이 없으므로 블록 생성 보상에 대한 진입 장벽이 낮다는 것입니다. 이 보고서에서는 두 합의 시스템의 장단점을 검토하고 Bitcoin 및 작업 증명 접근법에서 일반적으로 발생할 가능성이 거의없는 공격에 대해 기존의 지분 증명 구현이 취약하다는 것을 보여줍니다.


<h3> 1. 이론 </h3>
Bitcoin과 같은 암호화폐 시스템은 사용자가 자신의 잔액을 알 수 있게하는 상태 정보를 가지고 있다. Bitcoin의 경우, 시스템 상태는 각 출력을 암호로 잠겨있고 사용하지 않은 트랜잭션 출력(unspent transaction outputs - UTXO)의 모음이므로 사용자가 UTXO를 사용하기 위해 소유권 증명을 제공해야 한다. 숨김없이 잔액을 저장하는 대신에, Bitcoin 및 기타 디지털 통화는 사용자의 트랜잭션에 대한 전체 기록을 유지 관리하여 시스템의 현재 상태 및 모든 과거 상태를 추론 할 수 있습니다. 

트랜잭션은 시스템 상태에 대한 아주 작은 변경을 나타낸다. 트랜잭션은 블록으로 그룹화된다. 블록들은 블록 체인이라고하는 순서가 있는 거래더미로 구성된다. 블록 체인을 구성하기 위해, 각 블록은 이전 블록을 가리키는 정보(reference)를 가지고 있다. 사슬의 첫 번째 블록은 기원 블록(genesis block)이다. 이 블록은 이전 블록을 가지고 있지 않고, 보통 프로토콜에 하드 코딩된다. 암호 화폐 프로토콜에 의해 설정된 규칙에 따라 새 블록이 생성된다. 이 규칙의 중요한 기능은 블록 체인에 대한 공격으로부터 보호하고 블록 체인의 여러 인스턴스가 나타나는 경우 합의(consensus)에 도달하는 것이다. 작업 증명과 지분 증명는 유효 블록에 대한 두 종류의 제한을 나타내고, 두 가지 다른 합의 메커니즘을 의미한다.

<strong> 정의 1.</strong > 이전 블록으로 B를 참조하는 블록을 발견하려고하면, 사용자는 블록 B의 위(on top)에서 작업한다고 말한다. 

B는 블록 체인 전체를 고유하게 결정하므로, 최신 블록이있는 블록 체인을 나타낼 수 있으며 발견되는 블록들은 블록 체인 B의 위에 있다.

암호화폐 시스템은 P2P(peer-to-peer)인터넷 프로토콜을 통해 통신하는 통화을 위한 인프라 공급자에 속한 데이터베이스 복사본과 함께 분산 데이터베이스로 볼 수 있다. 
CAP(일관성, 가용성 및 파티션 허용 오차) 정리 [2]의 관점에서 암호화폐 시스템은 사용할 수 있고,(모든 요청이 응답을 받음), 파티션 내성이 있다(일부 노드가 실패하더라도 서비스를 여전히 수행함). 그러나 일관적이지는 않다. 때때로 시스템의 서로다른 사용자는 시스템의 다른 상태를 현재 상태로 관찰 할 것이다. 경우에 따라 불일치는 새로운 블록 해시가 발견되었지만 시스템의 모든 사용자에게 아직 릴레이되지 않은 상황에 해당한다. 궁극적인 일관성을 얻기 위해서는[3], 사운드 컨센서스 프로토콜은 다음 요구 사항을 부과해야한다.

<strong> 조건 1.</strong> 블록을 발견 한 사용자는 네트워크를 통해 즉시 브로드 캐스트하고 자신을 위해 보유하지 않도록해야합니다.

다른 경우, 시스템 불일치는 여러 개의 분기로 분할되는 블록 체인으로 인해 발생하며(그림 1), 블록 체인 분기(forking)의 다양한 원인이 있습니다.

• 두 명의 사용자가 거의 동시에 새 블록을 발견한다. 

• 공격자가 블록 체인을 분기하여 완료된 트랜잭션을 되돌리려 고 시도합니다. 

의도적 인 분기를 막기 위해, 사운드 컨센서스 프로토콜은 다음 요구 사항을 추가해야한다.

<strong> 조건 2.</strong> 사용자는 중급 사슬 위에 블록을 발견하지 말아야한다. 보다 정확하게, 블록 B를 참조하는 알려진 블록 B '가있는 경우, 사용자는 B를 빌드 할 이유가 없어야합니다

그림 1의 상황에서, 조건 1-2 : B_(i+2), B^''_(i+1) 및 B^''_(i+2)에 따라 블록 체인을 확장하기위한 기준으로 세 개의 블록만 사용할 수 있다. 유효한 블록 체인에는 추가 제한 사항이 있다. 대부분의 경우 이러한 조건은 최대 블록 수 (합리적인 사용자가 자신의 체인에서 작성할 수있는 블록에서 B''i + 1을 제외)가있는 체인을 선택하는 것이다. 합의 규칙의 목표는 단일 사슬의 선택을 보장하는 것이다. 그러나 일반적으로 일부 규칙은 사용자에 따라 다르다. 예를 들어 길이가 동일한 Bitcoin 블록 체인이 여러 개인 경우 먼저받은 블록 체인 블록 체인을 선택해야한다. 따라서 모든 사용자에 대해 동일한 블록 체인을 선택하는 방법은 없다 (사용자에 따라 규칙을 따르는 것이 매우 어렵거나 불가능하기 때문이다).

시스템이 궁극적으로 일관성을 가지려면 그 합의 프로토콜은 다음 세번째 요구 사항을 충족시켜야한다.

<strong> 조건 3.</strong> 합의 규칙은 블록 체인 분기(fork)를 해결하는 방식으로 구성되어야 한다. 즉, 경쟁 지점 중 하나가 합리적인 시간 내에 다른 지점을 모두 인수해야 한다. 

우리는 작업 증명과 지분 증명 알고리즘을 사용하여 블록을 발견하기위한 별도의 용어를 사용할 것이다:

<strong> 정의 2. </strong> 작업 증명 프로토콜에 의해 시행된 과도한
 계산 문제를 푸는 과정을 (블록) 마이닝(mining) 이라고 한다.

<strong >정의 3. </strong> 스테이크 프로토콜의 증명에 의해 과도한 계산 문제를 푸는 과정을 (블록) 마인팅(minting) 이라고 한다.

<h3> 1.1 작업 증명 </h3>

작업 증명 알고리즘으로 보호 된 암호화폐 시스템의 예로 Bitcoin을 고려해보자. Bitcoin의 각 블록은 두 부분으로 구성된다.

• 블록 생성 시간, 이전 블록에 대한 참조 및 트랜잭션 블록의 Merkle 트리 루트 [4]와 같은 주요 매개 변수의 블록 헤더 

• 트랜잭션 차단 리스트.

특정 블록을 가리키기 위해, 그 헤더는 SHA-256 함수 [5]로 두 번 해시된다. 결과 정수 값은 구간 [0, 2^256 - 1]에 속한다. 다른 방식의 가능한 구현을 설명하기 위해, 우리는 다양한 인수 및 범위 [0, M]와 함께 일반 해시 함수 hash (·)를 사용한다. 예를 들어, 함수의 인수는 이진 문자열로 처리되고 함께 병합되어 SHA-256 해싱 함수에 전달할 수있는 단일 인수를 형성 할 수 있다. 

블록 참조는 작업 증명 프로토콜에 사용된다. 블록이 유효하다고 간주 되려면 해당 참조가 특정 임계 값을 초과하지 않아야한다.

hash(B) <= M/D

여기서 D ∈ [1, M]은 목표 난이도를 뜻한다. 블록 헤더에서 가능한 모든 변수를 반복적으로 반복하는 것 이외에는 (1)을 만족하는 B를 찾기위한 알려진 방법이 없다. D의 값이 높을수록 유효한 블록을 찾는 데 더 많은 반복이 필요하다. 기대 연산 수는 정확히 D 이다. 

유효한 블록을 찾기 위해 초당 r 연산을 수행 할 수있는 하드웨어가있는 광부의 시간주기 T (r)는 비율 r / D로 기하 급수적으로 분산된다 (부록 A 참조).

해시 파워 r1, r2, ..., rn을 가진 n명의 Bitcoin 광부를 고려하자. 광부가 발견된 블록을 알리고 블록이 다른 광부에게 즉시 도달한다고 가정하자. 블록 T를 찾는 시간은 확률 변수 T(ri)의 최소값과 같다. 지수 분포의 특성에 따르면, T도 기하 급수적으로 분포한다.

마지막 방정식은 광산이 공정하다는 것을 보여준다. 해시 파워 p를 가진
 광부는 다른 광부보다 먼저 블록을 풀기 위해 동일한 확률 p를 가진다. Bitcoin에서 사용 된 작업 증명이 조건 1-3을 만족한다는 것을 알 수 있다.

<h3> 1.2 지분 증명 </h3>

지분 증명 알고리즘에서, 부등식 (1)은 블록 속성이 아닌 특정 PoS 프로토콜 암호화폐에 대한 사용자 소유권에 따라 수정된다. 주소가 A이고 밸런스 밸런스 (A)가있는 사용자를 생각해보십시오. 일반적으로 사용되는 스테이크 알고리즘의 증명은 다음과 같은 조건을 사용한다.

다양한 이유로 인해 일부 암호화폐는 (2)의 수정 된 버전을 사용하고, 이는 해당 섹션에서 논의한다. 

(1)과 달리 사용자가 변경할 수있는 유일한 변수는 방정식 (2)의 왼쪽 부분에있는 타임 스탬프 t입니다. 주소 잔액은 프로토콜에 의해 잠겨 있다. 예를 들어, 프로토콜은 하루 동안 움직이지 않은 자금에 기초하여 균형을 계산할 수 있다. 그 대신에, PoS 암호화폐는 Bitcoin이하는 것처럼 사용되지 않은 트랜잭션 출력을 사용할 수 있다. 이 경우 잔고는 자연스럽게 잠긴다. 스테이크 프로토콜의 증거는 가능한 t값에 제한을 가한다. 예를 들어, t가 네트워크 노드의 UTC 시간과 1 시간 이상 차이가 나지 않아야하는 경우 사용자는 7200 개의 t 값만 시도 할 수 있다. 따라서 지분 증명에 관련된 많은 계산이 필요하지 않습니다. 

(2)를 만족하는 주소 A와 타임 스탬프 t와 함께 사용자는 주소의 소유권 증명을 제공해야 한다. 이를 달성하기 위해, 사용자는 자신의 서명으로 새롭게 작성된 블록에 서명 할 수 있다. 유효한 서명을 생성하려면 주소 A에 해당하는 개인 키가 있어야 한다. 

주소 A에 대한 블록을 찾는 시간은 비율 bal (A) / D (부록 A 참조)와 함께 기하 급수적으로 분산 된다. 결과적으로, (2) 지분 증명의 구현은 공정하다 : 유효한 블록을 생성 할 확률은 순환중인 통화의 총 금액에 대한 사용자의 잔액 비율과 동일하다. 전체 네트워크에 대한 블록을 찾는 시간은 비율 Σ a bal (a) / D로 기하 급수적으로 분산 된다.

따라서 화폐의 화폐 공급이 a (a)로 고정되어 있거나 예측 가능한 비율로 증가하면, 어려움 D는 미리 알고 있어야 한다.

<h3> 1.3 위임된 지분 증명 </h3>

위임된 지분 증명 (DPoS)는 기본 PoS 합의 프로토콜의 발전을 설명하는 일반적인 용어이다. DPoS는 BitShares (2.5 절)뿐만 아니라 Slasher 및 Tendermint (4 절)와 같은 제안 된 알고리즘에서도 활용된다. 이 프로토콜에서 블록은 자신의 의무에 대해 보상을 받고 악의적 인 행동 (예 : 이중 지출 공격에 참여)에 대해 처벌되는 미리 결정된 사용자 집합에 의해 작성 된다. DPoS 알고리즘에서, 대리자는 다음 두 가지 별도 프로세스에 참여한다. 

• 트랜잭션 블록 작성 

• 생성 된 블록의 디지털 서명을 통해 유효성 검증.

단일 사용자가 만든 블록이 유효하다고 간주되는 동안 블록은 일반적으로 둘 이상의 대리자가 서명해야합니다. 

서명 블록에 적합한 사용자 목록은 특정 규칙을 사용하여 주기적으로 변경 된다. 예를 들어 Slasher에서 각 블록의 대표는 지분 및 블록 체인 기록을 기반으로 선택 된다. 각 블록에 대한 대리자 집합은 일반적으로 작다. 주목할만한 예외는 Tendermint이다. 각 블록은 시스템의 사용자 중 누구라도 서명 할 수 있다. 일부 DPoS 버전에서는 대의원이 시간 제한 보안 계정 (악의적 인 행동의 경우 몰수 됨)에 자금을 입금하여 약정을 표시해야합니다. 이 버전의 DPoS는 종종 입금 기반의 스테이크 증명이라고합니다. 위임 된 스테이크 증서는 (2)의 조건을 사용하지 않습니다. 스테이크는 다음 방법 중 하나를 사용하여 DPoS에 포함됩니다 : 

• 대의원은 시스템의 지분을 기반으로 선출 될 수 있습니다. 

• 대의원은 투표자의 스테이크에 따라 투표권을 가진 시스템의 모든 사용자로부터 투표를받을 수 있습니다. 

• 유효한 블록 보안 보증금의 크기에 비례하는 권한을 가질 수 있습니다. 

전반적으로 위임 된 위임 증거는 기본 PoS보다 덜 표준화되어 있습니다. 우리는 해당 섹션의 기존 구현을 자세히 설명합니다.

<h3> 1.4 합의 프로토콜의 목적 (Objectivity of Consensus Protocols) </h3> 

합의 프로토콜의 임무 중 하나는 새로운 노드가 피어 노드로부터 수신 한 정보를 기반으로 시스템의 현재 상태를 결정할 수있는 방법을 제공하는 것이다. 이 작업은 노드 중 일부가 Sybil 공격을 수행하는 파티에 속할 수 있기 때문에 쉬운 일은 아니다[7].

<strong > 정의 4 </strong>([8]) . 합의 프로토콜은 새로운 노드가 프로토콜 규칙 (예 : 기원 블록의 정의)과 시스템 전체에 전파되는 메시지 (예 : 일련의 메시지 집합)에 기반하여 나머지 네트워크와 동일한 현재 상태에 독립적으로 도달 할 수있는 경우 객관적입니다.(예, 모든 블록의 집합). 

작업 증명 합의는 객관적인 프로토콜의 한 예입니다. 새로운 노드가 적어도 하나의 "정직한"사용자와 연결되어있는 한, 누적 계산상의 어려움이 더 많으므로 유효한 블록 체인을 선택할 것입니다. 반면 지분 증명은 객관적이지 않습니다. 실제로 상당한 컴퓨팅 성능을 가진 공격자를 고려하자. 공격자의 포크가 충분히 길다면 공격자가 제어하는 ​​계정 만 활성화되는 상황을 반영하여 공격자의 포크가 조정된다. 이렇게하면 공격자가 유효한 블록 체인보다 긴 체인을 생성 할 수 있습니다. 장거리 포크는 시스템의 기존 사용자에 의해 거부 될 수 있지만 (예 : 가능한 포크의 길이를 제한하는 규칙을 도입하여) 현재 상태에 대한 사전 지식이없는 신규 사용자는 여전히 공격자의 블록 체인을 선택한다.

<strong > 정의 5. </strong> 시스템의 현재 상태를 독립적으로 결정하기 위해 노드가 프로토콜 상태 및 시스템 전반에 전파되는 메시지 이외에 최근 상태를 필요로한다면 컨센서스 프로토콜은 약한 주관적이다. 

지분 증명의 경우, 과거에 N 블록보다 많은 분기점을 갖는 포크를 허용하지 않는 규칙이 있다면, 깊이 N 이하의 블록의 내용을 판독하여 현재의 체계. 새 사용자는 신뢰할 수있는 출처 (예 : 해당 통화 전용 웹 사이트)에서이 블록에 액세스 할 수 있습니다. 이 방법은 PoS 시스템의 보안 및 분산화 측면을 약화시킬 수 있지만, 약한 주관성을 사랑하는 법을 배웠던 [8], 약한 주관성은 컴퓨터 중심 및 사회적 주도를 결합하는 좋은 방법이라고 주장됩니다 보안.

<h3> 구현 </h3>

현재 스테이크 컨센서스의 증거에 기반한 주목할만한 암호화가있다 (표 1).

• Peercoin 또는 PPCoin (peercoin.net) 

• Nxt (nxt.org) 

• BlackCoin (blackcoin.co) 

• Novacoin (novacoin.org). 

위임 된 증빙은 디지털 자산 인 BitShares (bitshares.org)에서 사용합니다. Ethereum (ethereum.org) 개발자는 컨센서스를 위임 된 위임 증거로 변경할 계획이다. 현재 Ethereum은 독점적으로 작업 증명 의존한다.


2.1 피어 코인

 Peercoin 또는 PPCoin은 2012 년 익명의 개발자 Sunny King이 설립 한 디지털 통화입니다. Peercoin은 작업 증명과 지분 증명의 조합을 사용합니다 [10].

• 작업 증명은 새로운 동전의 분배에 사용됩니다.

• 스테이크의 증거는 트랜잭션을 보호하기 위해 사용됩니다. 즉, 트랜잭션 블록을 생성하는 주요 수단으로 사용됩니다.

Peercoin 블록 체인의 구조는 Bitcoin과 매우 유사하다. Peercoin은 Bitcoin과 마찬가지로 사용되지 않은 트랜잭션 출력을 기반으로 작동한다. 새로운 블록은 평균 10 분마다 발견된다. 트랜잭션은 UTXO와 출력을 참조하는 입력으로 구성된다. 

Peercoin은 Bitcoin과 같은 SHA-256 해싱 함수를 기반으로하는 동일한 작업 증명 알고리즘을 사용한다. 그러나 채광 보상은 블록 높이가 아니라 표적 난이도에 따라 다르다. 어려움이 증가하면 보상이 내려간다. 난이도가 16 배 상승하면 블록 보상이 반으로 줄어든다. 광산 보상이 0에 가까워 질수록 PoS에 비해 PoW를 사용하는 인센티브가 줄어든다. 이와 관련하여 Peercoin은 장기적으로 에너지 효율적입니다. 

Peercoin의 지분 증명은 코인 나이의 개념을 기반으로 한다. 거래의 우선 순위를 정하기 위해 Bitcoin에 코인 나이가 도입되었다 [11].

<strong > 정의 6.</strong> 미사용 트랜잭션 출력의 코인 연령은 생성 된 이후의 기간으로 곱한 값이다. 이전에 소비되지 않은 결과물을 소비 한 거래는 동전의 나이를 소모하거나 소멸시킨다. 코인 나이 (coin age)는 Peercoin에서 유효한 블록 체인을 결정하는 데에도 사용됩니다. 이 블록 체인은 모든 블록에서 모든 트랜잭션에서 총 소비 된 동전 연령이 가장 높은 블록 체인이다 (체인 구성에 소요되는 총 예상 작업을 사용하는 Bitcoin 메커니즘 참조).

 Peercoin에서 사용되지 않은 출력 U를 사용하여 블록을 만들 수있는 가능성은 U가 생성 된 이후의 시간을 나타내는 age (U)가있는 조건에 의해 결정됩니다. PoS 변동 (3)은 통화량 대신 블록을 만들 가능성이 사용자에게 속한 UTXO의 총 유효 기간에 비례 함을 의미합니다. 발행 된 블록의 첫 번째 트랜잭션은 "운이 좋은"미사용 출력이 해당 블록을 작성한 사용자에게 속한다는 것을 증명하는 특수한 coinstake 트랜잭션입니다. coinstake 트랜잭션의 첫 번째 입력은 (3)을 만족하는 사용되지 않은 출력 U 여야합니다. 대부분의 경우 사용자는 자신의 가치를 다시 자신에게 보냄으로써 U를 소비합니다.

PoS 구현(3)의 주된 이유는 발행 된 블록 소유자를보다 고르게 분배하는 것입니다. 실제로 블록을 발행하면 UTXO의 총 유효 기간이 단축되므로 동일한 사용자가 다음 블록을 발행 할 확률이 줄어든다. 결과적으로 적은 지분을 가진 사용자는 오래 기다리면 블록을 만들 수 있습니다. 블록 체인에 안정성을 제공하기 위해 Peercoin은 주기적으로 브로드 캐스팅 된 체크 포인트를 사용합니다. 이러한 유형의 브로드 캐스팅은 중앙 집중화 지점을 도입합니다. 체크 포인트는 Bitcoin 프로토콜 [12]에 존재하지만, 스위치 오프 될 수 있고 방송되기보다는 프로토콜로 하드 코드됩니다; 따라서 Bitcoin의 체크 포인트 메커니즘은 중앙 집중화의 위험을 의미하지 않습니다.

2.2 Nxt

Nxt는 2013 년에 시작된 순수한 지분 증명 방식의 암호 화폐이다. Peercoin과 달리 Nxt는 새로운 동전을 만드는 작업 증명을 사용하지 않는다. 전체 10 억 동전 (NXT)의 공급이 기원 블록에서 시스템에 존재했다. 따라서 민트 블록에 대한 유일한 인센티브는 거래 수수료를 모으는 것뿐이다. 

Nxt의 트랜잭션은 Bitcoin 트랜잭션과 근본적으로 다르므로 다른 프로토콜 차이가 발생한다 [13].

• Nxt 트랜잭션에는 잠금 및 잠금 해제 스크립트가 없다. 대신 Nxt 프로토콜은 계정을 사용하여 트랜잭션의 보낸 사람과받는 사람을 인코딩한다.  이 제한은 Bitcoin과 비교하여 현명한 계약을 처리 할 수있는 시스템의 기능을 심각하게 제한한다.


• 다양한 유형의 거래가 있다. 예를 들어, 특별 거래를 위한 메시지, 칼라드 코인, 디지털 상품 등이 있다. 

• 블록의 트랜잭션 수에는 하드 코딩 된 제한이 있습니다 (255 자 이내). 반면 블록 간의 평균 시간은 1 분입니다.


• 모든 트랜잭션에는 만료 시간 (기본적으로 24 시간)이 있습니다. 만료 시간이 지나면 블록에 포함되지 않은 트랜잭션은 메모리 풀에서 제거되며 다시 보내야 한다. 

Nxt는 지분증명의 수정 한 버전을 사용한다. (2) 대신 블록을 만들 수 있으려면 사용자 계정 A에 대해 부등식을 유지해야 한다. (4)에서 Bprev는 블록 체인을 확장하는 데 사용되는 블록이고, t는 Bprev가 생성 된 이후 경과 된 시간이다. 따라서, 새로운 블록이 네트워크를 통해 전파 된 후, 임의의 주어진 사용자에 대한 PoS 조건을 만족시킬 기회는 초기에는 낮고 시간이 경과함에 따라 증가한다. (4)의 해싱 함수는 다음과 같이 계산됩니다.

1. Bprev의 특수 필드 (생성 서명) 사용
2. 계정의 공개 키로 세대 서명 서명하기
3. 결과 서명의 처음 8바이트 사용.

계정에 해당하는 공개 키가 공개되어 있으므로 누구나 (4)가 모든 사용자 계정을 보유하고 있는지 확인할 수 있다. Bitcoin에서와 같이 Nxt의 유효한 블록 체인은 최대 예상 총 난이도 D 인 체인으로 결정된다.

(2)와 다르게, (4)는 사용자 A가 영향을 줄 수있는 변수를 포함하지 않습니다. 따라서 Nxt의 PoS에는 다음과 같은 흥미로운 속성이 있다. 다음 블록의 의사를 합리적인 정확성으로 예측할 수 있다. 이렇게하려면 모든 사용자 계정을 찾아야한다.

 Nxt는 Bitcoin에 비해 다른 기본 확률 모델을 가지고 있습니다. 빅 플레이어에게 유리하다. 사용자가 상당량의 통화를 보유하고있는 경우, 블록을 발행 할 확률은 그의 지분보다 높다 (부록 B 참조).

2.3 노바 코인

  Novacoin은 Peercoin과 원칙적으로 매우 유사한 작업 증명/ 지분 증명 방식의 하이브리드 방식이다. 주요 차이점은 다음과 같다. 

• Novacoin은 광산업에 대해보다 보수적 인 보상 공식을 사용합니다. Peercoin에서 16x에 비해 보상은 64x 배수로 반감됩니다 [15].

 • 코인 일 무게 대신 코인 일 무게에 근거한 약간 다른 방법이 스테이크 증명에 사용됩니다 (3). 또한, 스테이크 블록 증명을위한 coinstake 보상은 소비 된 동전 연령과 PoS 난이도에 따라 달라집니다 [16]. 노바 코인의 동전 일 무게는 코인 나이와 비슷하게 계산되며, 동전 교환 일수는 30 일이며, 동전 주일은 90 일입니다. 예를 들어, 1 Novacoin 값을 가진 UTXO의 동전 일 무게는 다음과 같이 시간이 변합니다 :

3. 공격과 문제점

이 절에서는 PoS 기반 컨센서스에서 발생할 수있는 공격과 프로토콜 별 공격에 대해 설명합니다. 작업 증명이 없는 암호 화폐에서 여러 가지 공격 설명이 이루어진다 [19]. 

PoS 프로토콜의 대부분의 문제는 프로토콜이 블록 체인을 제외하고는 아무것도 인식하지 못하기 때문에 발생한다[20]. 작업 증명 시스템에는 외부 요인, 즉 (1)에 대한 해결책을 찾는 데 관련된 계산 작업량이 있다. 지분증명에서는, 실제로 블록 체인을 물리적으로 "고정"하는 것은 없다. 따라서 PoS 컨센서스를 직관적으로 공격에 취약한 것으로 볼 수 있다.

3.1 손해가 없는 문제

문제 (2)에 의존하는 스테이크 알고리즘의 순수한 증명은 중대한 문제가 있다. 블록 체인의 분기점 (우발적이든 고의적이든)이 존재하는 경우 네트워크의 모든 사용자에 대한 합리적인 행동은 두 가지 분기의 민트 블록에 있다. 작업 증명 알고리즘을 사용하면 이러한 동작이 비합리적이다. 여러 브랜치에서 리소스를 분리함으로써 광부는 각각의 블록을 찾을 확률을 줄어들게 된다. PoW 시스템의 최적의 전략은 항상 단일 지점에서 마이닝을 하는 것이다. 대조적으로, 지분 증명에서는 사용자가 다수의 블록 체인 브랜치 (branchchain branch)를 생성하려고 시도하는 경우, 블록을 발견 할 확률은 감소하지 않는다. 따라서, PoS 시스템에서의 합리적인 행동은 사용자가 알고있는 모든 가지 위에 민트 블럭을 만드는 것이다. 그보다 나쁘지 만, 순진한 PoS는 조건 2를 만족하지 못합니다. 상황에 따라 사용자가 중간 블록 체인 위에 구축하는 것이 적절할 수 있습니다. 예제는 3.4 절을 참조하세요. 

문제는 이중 지출 또는 블록 체인 포크에 의존하는 다른 종류의 공격을 쉽게 수행 할 수있게 한다. 시스템 사용자가 공격이 성공할 수 있다고 생각하는 한 공격자의 블록 체인 위에 작성하여 공격을 지원한다. 통화량이 많은 사용자가 포크 공격에 대비하여 돈을 잃을 까봐 두려워 할지라도 통화가 많은 사용자에게 고르게 분산되면 공격이 성공할 가능성이 더 크다. 

손해가 없는 문제에 대한 몇 가지 제안 된 해결책이 있다. Delegated PoS 알고리즘은 일반적으로이 문제에 영향을받지 않는다. 왜냐하면 블록 광부의 자금 형태로 지분이 있기 때문입니다. 이 자금은 광부가 시스템에 대한 공격에 참여할 경우 압수된다.

3.2 초기 배포 문제

지분 증명 시스템에서, 초기 동전 보유자는 동전 잔고가 자신의 재산에 직접적으로 기여하므로 자신의 동전을 제 3 자에게 공개 할 동기를 갖지 않을 것이라는 우려가 항상 있다. 비트 코인 (Bitcoin) 및 기타 PoW 시스템에서는 초기 얼리 어답터가 나머지 사용자와 동일한 위치에 있다. 동전을 채취하려면 하드웨어를 지속적으로 개선하고, 자원 소비를 최적화화 한다. 지분 증명 시스템에서, 시스템이 방금 출시되었을 때 (예 : $ 1,000) 코인의 10 %를 획득 한 사용자는, 시스템이 인기를 얻었을 때 동일한 자금을 가진 사용자와 비교하여 이점이 있으며 이 때의 1,000 달러는 모든 동전에서 0.01%로 변환된다. 

이러한 상황을 처리하기 위해 PoS 구현은 초기 자산을 분배하기 위해 추가 알고리즘을 사용한다. 예를 들어, Peercoin과 Ethereum은 새로운 동전을 만들기 위해 작업 증명 알고리즘을 사용한다 (4 절 참조).

3.3 장거리 공격

PoS 합의가있는 시스템에서, 충분한 계산 능력을 가진 공격자는 첫 번째 블록부터 시작하여 대체 블록 체인을 만들려고 시도 할 수 있다. PoW 타입의 시스템에서 이 공격은 처음부터 블록 체인을 구축하는 데 필요한 엄청난 양의 계산 능력이 필요하기에 방지 된다. 그러나 이 임무는 지분 증명의 가능성이 있습니다. 공격자가 동전을 건물 블록 체인에서 자유롭게 움직일 수 있기 때문에 그는 검색 공간의 차원이 훨씬 더 높습니다. 따라서 이러한 종류의 공격은 최근의 분기점을 가진 대체 블록 체인을 만드는 것이 바람직 할 수 있다. 공격은 대다수의 대표자가 수행 할 수있는 위임 된 스테이크 증언에서 계속됩니다. 장거리 공격을 방지하기 위해 프로토콜은 분기 지점의 최대 허용 깊이를 지정할 수 있습니다. 예를 들어, Nxt에서 사용자는 마지막 블록 (12 시간에 해당) 이상의 블록 체인에서 기존 블록 체인과 다른 경우 대체 블록 체인을 허용하지 않을 수 있습니다. 그러나이 제한은 새로운 사용자의 문제를 해결하지 못합니다. 새로운 사용자가 네트워크에 연결하면 자신의 진위 여부에 대한 사전 지식없이 여러 개의 블록 체인이 표시됩니다. 공격자의 블록 체인이 프로토콜 측면에서 유효한 블록 체인보다 더 바람직하다면, 새로운 사용자는 대신 그것을 채택 할 것입니다. 올바른 블록 체인인지 알 수있는 한 가지 방법은 신뢰할 수있는 소스에서 다운로드하는 것입니다. 그러나 이는 시스템을 반 집중화하여 완전히 신뢰하지는 못하게 만듭니다. 그럼에도 불구하고 신뢰할 수있는 소스에서 블록 체인 다운로드는 거의 모든 기존의 스테이크 시스템 증명에 사용된다.

3.4 뇌물 공격

이 공격에서 공격자는 다음과 같은 방법으로 자금을 이중으로 사용하려고 시도합니다.

1. 물건이나 서비스를 산다.

2. 지불 거래가 판매자에 의해 확인 된 것으로 간주 될 때까지 기다린다.

3. 지불 거래를 포함하지 않는 절단 된 블록 체인 위에 구축하기위한 보상을 발표해라. 예를 들어 상인이 6 회의 확인을 기다리는 경우, 공격자는 6 개의 최신 블록이없는 블록 체인으로 시작한다. 공격자는 공격자의 블록 체인 위에 만있는 사용자에게 더 많은 보상을 제공 할 수 있다. (이 기능이 없으면 침입자의 블록 체인이 올바른 것을 따라 잡을 수 없다).

4. 대부분의 이해 관계자의 지지를 얻기 위해 블록 체인 길이와 올바른 블록 체인 길이가 같아 지더라도 공격자는 뇌물을 계속 지불 할 수 있다. 

공격에 실패한 사용자는 공격이 실패하더라도 잃는 것이 없다. 공격자는 유료 뇌물의 총액이 물품의 가치보다 적으면 공격이 수익성이 있다. 비교하기 위해, PoW 시스템에서 유사한 공격은 침입자에게 광부 대다수에게 뇌물을 제공해야합니다. 게다가,이 경우 광부들은 공격이 실패 할 경우 계산에 소비되는 자원을 잃어 버리므로 뇌물의 양은 엄청나게 많을 것이다. 3.1 절에서 설명한 이유 때문에 위임 된 PoS 시스템에서는 공격이 가능하지 않다.

<!--
3.5 코인 연령 누적 공격

이 공격은 피어 코인과 사용자의 지분을 측정하기 위해 부를 대신 동전 대신 사용하는 시스템에 국한됩니다. Peercoin 프로토콜의 첫 번째 버전에서는 동전 연령이 제한되었습니다. 즉, 충분히 길게 기다리면 공격자가 네트워크를 효과적으로 추월하기에 충분한 시간을 축적 할 수 있습니다. 예를 들어, 모든 동전의 5 %를 소유 한 공격자가 돈을 여러 개의 출력으로 나눠서 UTXO의 나이가 평균보다 10 배가 될 때까지 기다릴 수 있습니다. 그 후, 공격자는 이중 소비 또는 다른 악의적 인 활동을 수행 할 확률이 높은 (각 UTXO가 충분히 작 으면) 여러 블록을 연속적으로 처리 할 수 ​​있습니다. 이 공격을 시도하는 사용자가 여러 명이면 네트워크가 손상 될 수 있습니다. 이후 버전의 Peercoin 프로토콜에서는 UTXO의 나이가 90 일로 제한됩니다. 마찬가지로, 동전 연령 파라미터는 Novacoin과 BlackCoin에서 제한됩니다. 상한선 제거는 누적 공격을 상당히 덜 일으키지 만, (3)의 지분 대신에 동전 시대를 사용함으로써 얻을 수있는 이점을 감소시킵니다.

3.6 사전 계산 공격

A를 높이 h에있는 특정 블록 Bh의 minter 라하자. 즉, A는 Bh에 대응하는 파라미터로 (2)를 만족시킨다. A가 상당한 컴퓨팅 능력을 소유하면, 그는 다음 블록 Bh + 1을 생성 할 수 있도록 블록 Bh의 해시에 영향을 줄 수있다. Bh에 새로운 거래를 추가함으로써 자신을 위해 Bh + 1을 예약하기 위해 A는 모든 계정을 검색하고 허용 된 시간 스탬프 t마다 조건 (2)이 성립하는지 계산합니다. Bh의 해시가 "불량"(bad) 인 경우, 즉 계산 결과 다른 블록이 다음 사용자가 작성한 것으로 표시되면 공격자는 삽입 된 트랜잭션의 매개 변수를 변경하고 다시 시도합니다. 공격자는 공정한 것보다 많은 수수료를 모으기 위해 블록의 긴 체인을 만들 수 있으며 이중 스택을 시도 할 수 있습니다 (블록 체인을 비밀리에 구축 한 다음 한꺼번에 모두 해제하여 올바른 블록 체인을 공격자가 원하는 트랜잭션으로 무시할 수 있음). 거꾸로). 사전 계산 공격의 효과는 공격자의 지분 및 시스템의 총 계정 또는 UTXO 수에 따라 다릅니다. PoW 시스템에서이 공격은 사실상 불가능합니다. 유효한 블록을 생성하는 것보다 "좋은"해시를 가진 블록을 생성하는 데 더 많은 작업이 필요하기 때문입니다. 마찬가지로, 위임 된 PoS 시스템에서, 일련의 블록 서명자는 가장 새로운 블록의 속성에 의해 영향을받을 수 없다. 따라서 이러한 유형의 합의는 사전 계산 공격에 내성이 있습니다.


<p><small>This demo page has been used from <a href="http://jasonm23.github.io/markdown-css-themes/" target="_blank">http://jasonm23.github.io/markdown-css-themes/</a>.</small></p>

<h1>A First Level Header</h1>

<h2>A Second Level Header</h2>

<h3>A Third Level Header</h3>

<h4>A Fourth Level Header</h4>

<h5>A Fifth Level Header</h5>

<h6>A Sixed Level Header</h6>

<p>Now is the time for all good men to come to
the aid of their country. This is just a
regular paragraph.</p>

<p>The quick brown fox jumped over the lazy
dog&rsquo;s back.</p>

<hr />

<h3>Header 3</h3>

<blockquote><p>This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</p>

<p>Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
id sem consectetuer libero luctus adipiscing.</p>

<h2>This is an H2 in a blockquote</h2>

<p>This is the first level of quoting.</p>

<blockquote><p>This is nested blockquote.</p></blockquote>

<p>Back to the first level.</p></blockquote>

<p>Some of these words <em>are emphasized</em>.
Some of these words <em>are emphasized also</em>.</p>

<p>Use two asterisks for <strong>strong emphasis</strong>.
Or, if you prefer, <strong>use two underscores instead</strong>.</p>

<ul>
<li>Candy.</li>
<li>Gum.</li>
<li>Booze.</li>
<li>Red</li>
<li>Green</li>
<li><p>Blue</p></li>
<li><p>A list item.</p></li>
</ul>


<p>With multiple paragraphs.</p>

<ul>
<li><p>Another item in the list.</p></li>
<li><p>This is a list item with two paragraphs. Lorem ipsum dolor
sit amet, consectetuer adipiscing elit. Aliquam hendrerit
mi posuere lectus.</p></li>
</ul>


<p>Vestibulum enim wisi, viverra nec, fringilla in, laoreet
vitae, risus. Donec sit amet nisl. Aliquam semper ipsum
sit amet velit.*   Suspendisse id sem consectetuer libero luctus adipiscing.</p>

<ul>
<li>This is a list item with two paragraphs.</li>
</ul>

ㅇㅁㄴㅇㄹ
<p>This is the second paragraph in the list item. You&rsquo;re
only required to indent the first line. Lorem ipsum dolor
sit amet, consectetuer adipiscing elit.</p>

<ul>
<li><p>Another item in the same list.</p></li>
<li><p>A list item with a bit of <code>code</code> inline.</p></li>
<li><p>A list item with a blockquote:</p>

<blockquote><p>This is a blockquote
inside a list item.</p></blockquote></li>
</ul>


<p>Here is an example of a pre code block</p>

<pre><code>tell application "Foo"
    beep
end tell
</code></pre>

<p>This is an <a href="#">example link</a>.</p>

<p>I start my morning with a cup of coffee and
<a href="http://www.nytimes.com/">The New York Times</a>.</p>

### Code snippet

{% highlight python %}
if __name__ =='__main__':
    img_thread = threading.Thread(target=downloadWallpaper)
    img_thread.start()
    st = '\rDownloading Image'
    current = 1
    while img_thread.is_alive():
        sys.stdout.write(st+'.'*((current)%5))
        current=current+1
        time.sleep(0.3)
    img_thread.join()
    print('\nImage of the day downloaded.')
{% endhighlight %}

-->