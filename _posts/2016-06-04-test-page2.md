---
layout: post
title: test 다수는 충분하지 않다: 비트 코인 채굴은 취약하다
categories: others
---

##초록 

Bitcoin 암호화폐는 블록 체인이라고하는 공개 로그에 트랜잭션을 기록한다. 비트코인의 보안은 광부(miner)라고 불리는 참가자가 실행하는 블록 체인을 유지 관리하는 분산 프로토콜에 크게 달려있다. 기존의 지혜는 광업 프로토콜이 incentive-compatible 하고 소수 집단을 공모하는 것에 대비해 안전하다는 것을 주장한다. 즉, 광부에게 규정대로 프로토콜을 따를 것을 장려한다. 

* incentive-compatible : 각 유저의 선호도에 따른 선택이 최적의 결과를 내는 메카니즘을 말함(출처: Wikipedia)

Bitcoin 마이닝 프로토콜은 incentive-compatible 하지않음을 보여준다. 우리는 공모한 광부가 공정한 몫보다 더 큰 수입을 얻는 공격을 제시한다. 이 공격은 비트 코인에게 중대한 결과를 가져올 수 있다. 합리적인 광부들은 이기적인 광부에 합류하는 것을 선호할 것이며, 공모 그룹은 다수가 될 때까지 크기가 커질 것이다. 이 시점에서 Bitcoin 시스템은 분산 통화가 되지 않게 된다. 

특정 가정을하지 않는 한, 집단 광부의 집단 규모에 따라 이기적인 채광이 가능할 수 있다. 우리는 일반적인 경우에 Bitcoin을 보호하는 Bitcoin 프로토콜에 대한 실질적인 수정을 제안한다. 그것은 자원의 1/4 이하를 명령하는 풀에 의한 이기적인 채광을 금지한다. 이 임계 값은 잘못 가정된 1/2 경계보다 낮지 만 모든 크기의 그룹이 시스템을 손상시킬 수있는 현재의 상황보다 좋다.


## 1. 도입 

Bitcoin [23]은 최근 풍부하고 광범위한 생태계와 함께 대중적인 교환 매체로 등장한 암호화폐이다. Bitcoin 네트워크의 계산력은 42 × 10^18 FLOPS [9] 이상이며, 시가 총액은 2014 년 1 월 현재 약 120 억 달러입니다 [10]. Bitcoin의 운영의 중심에는 Bitchin 클라이언트 간의 모든 트랜잭션을 기록하는 블록 체인이라는 글로벌 공개 로그가 있다. 블록 체인의 보안은 광부라고 불리는 참가자들의 느슨하게 구성된 네트워크에 의해 해결되는 일련의 암호화 퍼즐에 의해 설정된다. 암호퍼즐을 성공적으로 해결한 각 광부는 일련의 트랜잭션을 기록하고 Bitcoins에서 보상을 얻을 수 있다. 광부가 더 많은 채굴 파워(자원)을 사용할수록 퍼즐을 먼저 해결할 가능성이 높아진다. 이 보상 구조는 광부가 자원을 시스템에 기여할 수 있도록 인센티브를 제공하고, 이는 분산 통화 환경에 필수적인 요소이다. 

Bitcoin 프로토콜은 광부 대다수가 정직해야 한다. 즉, 지정된대로 Bitcoin 프로토콜을 따라야된다. 구조에 의해서, 만일 광부의 공모집합이 네트워크의 광산 권력의 대다수를 지휘하게된다면, 통화는 분권화되지 않고 공모 그룹에 의해 통제된다. 예를 들어, 이러한 그룹은 특정 거래 또는 모든 거래를 금지 할 수 있다. 그러므로 광부들이 대규모 공모 그룹을 형성하는 것이 인센티브를 갖지 않도록 프로토콜을 설계하는 것이 중요하다.

Bitcoin 광부가 전략적으로 행동하고 풀(pool)을 형성한다는 경험적 증거가 있다. 특히, 보상은 드물고 무작위의 간격으로 주어지기 때문에, 광부는 소득 비율의 편차를 줄이기 위해 마이닝 풀을 형성한다. 그러한 수영장 내에서, 모든 구성원은 각 암호퍼즐을 푸는 것에 기여하고 보상을 그들의 기여에 비례하여 나눈다. 우리가 알고있는 한, 그러한 풀은 온화하고, 지금까지 프로토콜을 따랐다. 

사실, Bitcoin 채굴 프로토콜이 참가자들에게 공평하고 다수가 아닌 공격자에 의한 공격으로부터 안전하다는 것이 오랫동안 주장되어 왔다 (섹션 7). 트랜잭션 전파에 대한 최근 밝혀진 Sybil 공격을 제외하고, 소수의 광부가 프로토콜로부터 벗어남으로써 균형이 맞지 않는 이익을 얻을 수있는 알려진 기술이 없었다. 이 프로토콜은 광부가 통제하는 전체 채굴 파워의 비율에 비례하여 광부에게 보상을 한다고 믿었기 때문에 큰 풀의 광부는 작은 수영장에서와 동일한 수익을 올리는 것으로 믿어졌다. 결과적으로, 풀 운영의 고정 비용과 잠재적인 규모의 경제를 무시한다면, 광부들이 계속 늘어나는 풀에서 광부들이 공모하는 것의 장점이 없다. 그러므로 정직한 합리적인 광부에 의한 풀 형성은 시스템에 아무런 위협도 제기하지 않는다.


이 글에서는 기존의 지혜가 잘못되었음을 보여준다. Bitcoin 마이닝 프로토콜은 규정되고 구현 된대로 incentive-compatible 하지 않다. 우리는 소수자 풀이 풀의 공평한 분배보다 더 많은 수익을 얻기 위해 사용할 수있는 전략, 즉 전체 채굴 파워의 비율 이상의 이득을 얻을 수 있다. 

이기적 채굴(Selfish Mining)이라고 불리는 이 전략의 핵심 아이디어는 발견 된 블록을 비공개로 유지하여 의도적으로 체인을 포크하는 것이다. 정직한 노드는 공개 체인에서 계속 채굴을 하고 있고, 반면 작은 풀은 자체 개인브랜치에 있다. 공모 풀이 더 많은 블록을 발견하면 공용 체인에서 더 긴 리드를 개발하고 이러한 새로운 블록을 계속 비공개로 유지한다. 공공 브랜치가 풀의 개인 브랜치와 길이가 비슷해지면 이기적인 광부들은 개인 체인에서 블록을 대중에게 공개한다.

이 전략은 Bitcoin 프로토콜을 따르는 정직한 광부가 암호 퍼즐을 푸는 것에 자원을 낭비하여 목적을 달성하지 못하게 한다. 우리의 분석은 정직한 풀과 이기적인 풀이 자원을 낭비하는 반면, 정직한 광부는 비례적으로 더 낭비하며, 이기적인 풀의 보상은 네트워크의 광산 파워의 점유율 보다 더 많은 보상을 받는다. 경쟁 우위를 부여하고 이성적인 광부가 이기적인 광산에 가입하도록 유도한다는 것을 보여준다.

우리는 특정 임계 값 크기 이상으로, 이기적인 풀의 수익은 정직한 전략으로 수익보다 큰 풀 크기로 초 선형 적으로 상승한다는 것을 보여준다. 이 사실은 결과 시스템 다이나믹에 대해 중요한 영향을 미친다. 이기적인 채광 풀이 한계점에 도달하면 유리한 광부가 이기적 광부와 우선적으로 합류하여 다른 풀과 비교하여 더 높은 수익을 거둘 수 있다. 그러한 이기적인 채광 웅덩이는 다수로 빠르게 성장할 수 있다. 풀이 대다수 임계 값을 나타낼 경우 (시스템을 약화시키는 악의적 인 행위자, 아마도 합법적으로 또는 과장하여 통화를 빼앗 으려는 합리적인 행위자 또는 풀 인기에 대한 모멘텀으로 인해), 변경된 프로토콜로 전환 할 수 있습니다 풀 외부에서 생성 된 블록은 블록의 유일한 생성자가되어 모든 광산 수익을 얻습니다. 비밀리에 남아 있기를 원하는 대다수의 풀은 악의적 인 독점 기업으로 남을 수 있으며, 필요할 때 전체 수익을 올릴 수있는 능력과 이중 지출 공격을 개시 할 수있는 능력을 유지하면서 분산화의 환상을 제공하기 위해 제 3 자로부터 블록을 수락한다. 상인에 대한. 어느 쪽이든, 통화의 분산 된 성격은 붕괴 될 것이며, 단일 실체 인 이기적 풀 관리자가 시스템을 통제 할 것입니다.

임계값 크기를 초과하는 이기적인 채광풀이 Bitcoin 시스템에 위협이되므로, 우리는 임계 값이 네트워크에서 메시지 전파 속도의 함수로 어떻게 변하는지를 특징으로합니다. 높은 연결성과 정보 흐름에 대한 제어력이 좋은 채광 풀의 경우 임계 값이 0에 가깝습니다. 이것은 광부의 100 % 미만이 정직한 경우 시스템이 인센티브와 양립 할 수 없음을 의미합니다. 첫 번째 이기적인 광부는 정직한 직원보다 비례하여 더 높은 수익을 올릴 것이고 이기적인 채광 웅덩이의 수익은 수영장과 함께 초 선형 적으로 증가 할 것입니다 크기. 

우리는 Bitcoin 광업 프로토콜이 네트워크의 총 광산 전력의 1/3 이상을 차지하는 이기적인 광업 단지에 의한 공격에 대해 결코 안전하지 않음을 보여준다. 이러한 풀은 네트워크에서 모든 단일 블록 경주를 상실하더라도 광산 채굴 비율을 초과하는 광산 보상을 항상 수집 할 수 있다. 프로토콜이 도박에 견디는 것을 보장하기 위해 정직한 프로토콜을 따르는 데 필요한 Bitcoin 광량의 2/3 범위는 현재 가정 된 50 % 수치보다 훨씬 낮으며 실제로는 달성하기 어렵습니다. 마지막으로 1/4의 임계 값을 달성하는 Bitcoin 프로토콜에 대한 간단한 수정을 제안합니다. 이 변경 사항은 이전 버전과 호환되며 점진적입니다. 즉, 현재 고객이 겸손한 변경으로 채택 할 수 있고, 혜택을 제공하기 위해 전면적으로 채택 할 필요가 없으며 부분 채택은 비례하여 임계 값을 증가시킵니다.
요약하면,이 연구의 기여 내용은 다음과 같다. 

1. Bitcoin 광산이 인센티브와 호환되지 않는다는 것을 보여주는 이기적 광산 전략 소개 (3 절). 
2. 이기적 광산의 분석, 그리고 그것이 웅덩이에 유익 할 때 (제 4 절). 
3. 이기적 채광에 직면 한 다수 풀 형성 분석 (5 절). 
4. 임계 값을 0에서 1/4로 올리는 Bitcoin 프로토콜에 대한 간단한 하위 호환성 순차 수정 (섹션 6). 

우리는 블록 체인의 보안을 다루는 이전 작업을 알지 못합니다. 우리는 7 장의 관련 연구에 대한 개요를 제공하고 8 장에서 우리의 결과가 의미하는 바를 논의한다.

2 사전 준비

Bitcoin은 분산적이고 분산 된 암호화 통화이다 [8, 7, 23, 6]. Bitcoin 사용자는 클라이언트라고하며, 각 사용자는 주소(address)라고 하는 계정을 지정할 수 있다. 클라이언트는 거래를 형성하고 블록 체인이라고하는 글로벌 추가 전용 로그에 커밋하여 Bitcoins를 다른 클라이언트에게 보낼 수 있다. 블록 체인은 Bitcoins에서의 노력으로 보완 된 광부 네트워크에 의해 유지 관리된다. Bitcoin 거래는 Bitcoin 주소의 정당한 소유자만 자금을 이체 할 수있는 암호화 기술로 보호된다. 

광부는 Bitcoins의 소유권을 결정하는 블록 체인에 트랜잭션을 기록하는 역할을 담당한다. 시간 t까지 블록 체인의 접두어에 클라이언트의 주소와 관련된 트랜잭션의 총계가 x 인 경우 클라이언트는 x Bitcoins를 소유합니다. 광부는 지불되지 않은 인풋의 경우에만 트랜잭션을 허용한다.

2.1 블록 체인 및 채굴

블록 체인은 트랜잭션을 블록 단위로 기록한다. 각 블록은 고유 한 ID와 선행 블록의 ID를 포함합니다. 최조 블록(genesis block)이라고 불리는 첫 번째 블록은 프로토콜의 일부로 정의된다. 유효한 블록은 이전 블록의 해시, 현재 블록의 트랜잭션 해시 및 cryptopuzzle을 해결하기위한 보상으로 적립 될 Bitcoin 주소와 관련된 암호 퍼즐에 대한 솔루션을 포함한다. 이 프로세스를 Bitcoin 마이닝이라고하며, 용어를 약간 남용하여 블록 생성을 블록 마이닝이라고 한다. 특정 cryptopuzzle은 결과가 설정된 값보다 작아야하는 이중 해시이다. 이 값으로 설정된 문제 난이도는 블록이 10 분마다 평균 비율로 생성되도록 동적으로 조정된다. 

모든 광부는 단순히 오버레이 네트워크를 통해 다른 모든 광부에게 게시함으로써 체인에 유효한 블록을 추가 할 수 있다. 두 명의 광부가 선행 블록이 같은 블록 두 개를 만들면, 체인이 두 개의 분기로 갈라져 하나의 나무가 된다. 다른 광부는 이후 새 분기 블록을 분기에 추가 할 수 있다. 광부가 기존 블록 다음에 새로운 블록을 추가하려고하면 기존 블록에서 광산을 제거합니다??. 이 기존 블록은 지점의 머리 일 수 있습니다.이 경우 광산 광산은 지점의 머리에 또는 단순히 지점에 있습니다. 

광부들이 전 세계적으로 동의한 완전히 정렬된 일련의 거래를 유지해야하기 때문에, 가지의 형성은 바람직하지 않다. 포크를 해결하기 위해, 프로토콜은 광부에게 가장 긴 사슬을 채택하도록 지시한다 .1 모든 광부는 그들이 알고있는 가장 긴 사슬에 블록을 추가한다. 또는 동일한 길이의 가지가있는 경우 들어 본 첫 번째 블록을 추가한다. 이로 인해 분기 된 분기가 프 i (prune)됩니다. 제거 된 블록의 트랜잭션은 무시되며 클라이언트가 다시 제출할 수 있다. 

평균 광산 간격은 10 분이지만 오버레이 네트워크를 통한 블록 보급은 초 단위로 진행됩니다. 따라서 우발적인 분기는 거의 발생하지 않으며, 평균 60 블록마다 한 번 발생한다 [12]. 

광부가 블록을 생성하면 Bitcoins을 사용하여 보완된다. 이 보상에는 이전 거래가 포함 된 사용자가 지불 한 거래 당 수수료와 전에 존재하지 않은 새로운 Bitcoin 금액이 포함됩니다.

2.2 풀 형성 (Pool formation) 

블록을 채굴 할 확률은 관련된 암호 대 퍼즐을 해결하기 위해 사용 된 계산 자원에 비례한다. 광산 프로세스의 특성으로 인해 광산 사건의 간격은 단일 광부의 관점에서 높은 차이를 나타낸다. 전용 ASIC을 사용하는 단일 홈 광부는 블록을 수년 동안 채광하지 않을 것이다 [31]. 결과적으로, 광부는 일반적으로 풀으로 조직됩니다. 수영장의 모든 구성원은 함께 작업하여 각 블록을 채굴하고, 그 중 하나가 블록을 성공적으로 채광하면 수익을 공유합니다. 풀에 가입해도 광부의 예상 수익은 변하지 않지만 변동이 줄어들어 매월 수익이보다 예측 가능 해진다.

3.2 이기적 - 광산

이제 우리는 이기적인 채굴이라고 불리는 전략을 설명한다. 4절에서 볼 수 있듯이, Selfish-Mine은  충분한 크기의 풀이 광산의 비율보다 큰 수익을 얻을 수 있도록 한다. 일반성을 잃지 않고 단순하게, 우리는 광부가 이기적인 채굴 전략을 따르는 공모 소수 집단과 정직한 광업 전략 을 따르는 다수의 두 집단으로 나뉘어 진다고 가정한다. 정직한 광부가 단일 그룹 혹은, 집단 집단 이나 개별적으로 운영되는지 여부는 중요하지 않다.

이기적인 채굴 전략의 핵심 통찰력은 정직한 광부들이 오래된 퍼블릭 브랜치에서 낭비되는 계산을 수행하도록 강제하는 것이다. 구체적으로, 이기적인 채굴은 정직한 광부들이 블록 체인의 일부가 아닌 운명의 블록에 그들의 사이클을 보내도록 강요한다. 

이기적인 광부는 채굴된 블록을 선택적으로 노출시켜 정직한 광부의 업무를 무효화함으로써 이러한 목표를 달성 한다. 대략적으로 말하면, 이기적인 채광창은 채광 된 블록을 비공개로 유지하고 은밀하게 블록 체인을 분기하고 프라이빗 브랜치를 만든다. 그 사이에, 정직한 광부는 더 짧은, 퍼블릭 브랜치에서 마이닝을 계속한다. 이기적인 광부들이 전체 광산 권력 중 비교적 작은 부분을 차지하기 때문에, 그들의 프라이빗 브랜치는 퍼블릭 브랜치보다 훨씬 앞당겨지지 않을 것이다. 결과적으로, 이기적인 채굴은 사설 지부에서 대중에게 블록을 현명하게 드러냄으로써, 정직한 광부가 더 짧은 퍼블릭 브랜치를 버리고 최근 공개 된 블록으로 전환 할 것이다. 이것은 이전의 노력을 낭비되는 짧은 퍼블릭 브랜치에 소비하게하고, 블록의 더 많은 부분을 블록 체인에 통합함으로써 이기적 인 풀이 더 높은 수익을 얻을 수있게 한다. 

이러한 직관으로 무장 한 우리는 알고리즘 1에 제시된 이기적 마이닝 전략을 완벽하게 지정할 수 있다. 전략은 이기적 인 풀 또는 다른 사람들에 의한 마이닝 이벤트에 의해 유도됩니다. 그 결정은 이기적인 풀의 프라이빗 브랜치와 퍼블릭 브랜치의 상대적인 길이에만 의존한다. 다양한 공개 및 사설망 길이와 관련된 샘플 시나리오를 통해 이기적 마이닝 전략의 운영을 설명하는 것이 가장 좋다.

퍼블릭 브랜치가 프라이빗 브랜치보다 더 길어졌을때, 이기적인 채굴 풀은 퍼블릭 브랜치의 뒤에 있게된다. 이기적은 채굴자와 다른 이들 사이의 파워 차이 때문에, 이기적인 채굴자들이 메인브랜치보다 빠르게 브랜치를 만드는 기회는 작다. 결과적으로, 이기적인 마이너 풀은 그들의 프라이빗 브랜치가 뒤쳐졌을 때, 간단히 메인 브랜치를 채택한다. 다른이들이 새로운 블럭을 찾고, 이를 전파시키면 이기적인 풀은 이를 업데이트하고 새로운 퍼블릭 해드에서 마이닝을 한다.

이기적인 광부 풀이 블록을 발견하면 정직한 광부가 운영하는 퍼블릭 브랜치의 한 블록 앞서서 유리한 위치에 있다. 이 비밀 블록을 순진하게 게시하고 새로 발견 된 블록의 나머지 광부들에게 알리는 대신, 이기적인 광부는이 블록을 풀에 비공개로 유지한다. 이 시점에서 가능한 두 가지 결과가 있다. 정직한 광부가 퍼블릭 브랜치에서 새로운 블록을 발견하거나, 이기적인 풀의 선두를 무효로 만들거나, 풀이 두 번째 블록을 채굴하고 정직한 광부에 대한 주도권을 확장 할 수 있다. 

정직한 노드가 공용 지점에서 블록을 찾는 데 성공하여 이기적 풀의 리드를 무효화하는 첫 번째 시나리오에서 풀은 즉시 사설 분기 (길이 1)를 게시한다. 이것은 어느 쪽 지점이 이길 수있는 던지기를 만든다. 이기적인 광부들은 이전의 프라이빗 브랜치를 만장일치로 채택하고 확장하며, 정직한 광부들은 통보의 전파에 따라 다른 브랜치를 선택하게 된다. 이기적인 풀이 풀의 최근 공개 된 블록을 채택하지 않은 정직한 광부 앞에서 후속 블록을 채굴 할 경우 즉시 지점의 첫 번째 블록과 두 번째 블록의 수익을 향유하기 위해 게시한다. 정직한 광부가 풀의 공개 된 블록 이후 블록을 채굴하면 풀은 블록의 수익을 얻고 다른 그룹은 수익을 얻습니다. 마지막으로 정직한 광부가 자신의 블럭에서 블록을 채취하면 이기적인 풀에서 아무것도 얻지 못하고, 정직한 광부는 두 블록의 수익을 얻게 된다. 

이기적인 풀이 두 번째 블록을 찾는 데 성공한 두 번째 시나리오에서는 정직한 광부가 발견 한 것에 대항하여 쿠션을 제공하는 두 블록의 편안한 리드를 개발한다. 풀이 이 지점에 도달하면 프라이빗 브랜치의 머리에서 계속 채굴 된다. 다른 사람이 찾은 모든 블록에 대해 사설 지사에서 한 블록을 게시합니다. 이기적인 풀은 소수이기 때문에, 그 리드는 높은 확률로 결국 한 블록으로 축소된다. 이 시점에서 풀은 자체 분기를 게시한다. 프라이빗 브랜치는 퍼블릭 브랜치보다 한 블록 더 길기 때문에 모든 광부가 기본 브랜치로 채택하고 풀은 모든 블록의 수익을 얻게 된다. 이렇게하면 풀이 다시 분기 될 때까지 시스템이 단일 분기 만있는 상태로 돌아갑니다.

4. 분석

우리는 이기적인 풀이 α의 채굴 력을 가지고 있고 나머지가 (1 - α)를 갖는 시스템에 대해 예상되는 보상을 분석 할 수 있다. 

그림 1은 상태 시스템으로서 시스템의 진행 상황을 보여준다. 체계의 상태는 이기적인 웅덩이의 지도를 대표한다; 즉 풀의 개인 분기에있는 게시되지 않은 블록의 수와 퍼블릭 브랜치의 길이 간의 차이이다. 제로 리드는 상태 0과 0 '으로 분리된다. 상태 0은 분기가 없는 상태이다. 즉, 하나의 글로벌, 퍼블릭 최장 체인이 있다. 상태 0 '은 주된 지점과 이기적인 광부에게 사적이며 주된 지점과 일치하기 위해 발행 된 지점 인 길이가 1 인 두 개의 공개 지점이있는 상태이다. 그림의 전환은 이기적인 수영장이나 다른 사람들에 의한 광산 이벤트에 해당합니다. 이 사건들은 평균 빈도 α와 (1-α)의 지수 간격으로 발생 함을 상기하라.

상태 머신의 각 상태 전이와 관련된 빈도를 고려하고 해당 보상을 계산하여 이기적 광산에서 예상되는 보상을 분석 할 수 있다. 다양한 사례를 살펴보고 상태 전환을 유발하는 관련 이벤트를 설명합시다. 풀의 길이가 1 개인 사설 브랜치가 있고 다른 블록이 광업 블록 인 경우 풀은 즉시 브랜치를 게시하여 길이가 1 인 두 개의 공용 브랜치가됩니다. 이기적인 풀의 광부는 모두 풀의 브랜치에 있습니다. 왜냐하면 후속 블록 이 지점에 대한 발견은 수영장에 대한 보상을 줄 것입니다. 정직한 광부는 표준 Bitcoin 프로토콜 구현에 따라 처음 들어 봤던 지점에서 광산을 사용합니다. 우리는 수영장 블록에서 광산을 선택하는 정직한 광부의 비율을 γ로 표시하고 다른 지점에있는 다른 광산 광부 중 다른 광부 (1-γ)를 나타냅니다.


<!--
3.5 코인 연령 누적 공격

이 공격은 피어 코인과 사용자의 지분을 측정하기 위해 부를 대신 동전 대신 사용하는 시스템에 국한됩니다. Peercoin 프로토콜의 첫 번째 버전에서는 동전 연령이 제한되었습니다. 즉, 충분히 길게 기다리면 공격자가 네트워크를 효과적으로 추월하기에 충분한 시간을 축적 할 수 있습니다. 예를 들어, 모든 동전의 5 %를 소유 한 공격자가 돈을 여러 개의 출력으로 나눠서 UTXO의 나이가 평균보다 10 배가 될 때까지 기다릴 수 있습니다. 그 후, 공격자는 이중 소비 또는 다른 악의적 인 활동을 수행 할 확률이 높은 (각 UTXO가 충분히 작 으면) 여러 블록을 연속적으로 처리 할 수 ​​있습니다. 이 공격을 시도하는 사용자가 여러 명이면 네트워크가 손상 될 수 있습니다. 이후 버전의 Peercoin 프로토콜에서는 UTXO의 나이가 90 일로 제한됩니다. 마찬가지로, 동전 연령 파라미터는 Novacoin과 BlackCoin에서 제한됩니다. 상한선 제거는 누적 공격을 상당히 덜 일으키지 만, (3)의 지분 대신에 동전 시대를 사용함으로써 얻을 수있는 이점을 감소시킵니다.

3.6 사전 계산 공격

A를 높이 h에있는 특정 블록 Bh의 minter 라하자. 즉, A는 Bh에 대응하는 파라미터로 (2)를 만족시킨다. A가 상당한 컴퓨팅 능력을 소유하면, 그는 다음 블록 Bh + 1을 생성 할 수 있도록 블록 Bh의 해시에 영향을 줄 수있다. Bh에 새로운 거래를 추가함으로써 자신을 위해 Bh + 1을 예약하기 위해 A는 모든 계정을 검색하고 허용 된 시간 스탬프 t마다 조건 (2)이 성립하는지 계산합니다. Bh의 해시가 "불량"(bad) 인 경우, 즉 계산 결과 다른 블록이 다음 사용자가 작성한 것으로 표시되면 공격자는 삽입 된 트랜잭션의 매개 변수를 변경하고 다시 시도합니다. 공격자는 공정한 것보다 많은 수수료를 모으기 위해 블록의 긴 체인을 만들 수 있으며 이중 스택을 시도 할 수 있습니다 (블록 체인을 비밀리에 구축 한 다음 한꺼번에 모두 해제하여 올바른 블록 체인을 공격자가 원하는 트랜잭션으로 무시할 수 있음). 거꾸로). 사전 계산 공격의 효과는 공격자의 지분 및 시스템의 총 계정 또는 UTXO 수에 따라 다릅니다. PoW 시스템에서이 공격은 사실상 불가능합니다. 유효한 블록을 생성하는 것보다 "좋은"해시를 가진 블록을 생성하는 데 더 많은 작업이 필요하기 때문입니다. 마찬가지로, 위임 된 PoS 시스템에서, 일련의 블록 서명자는 가장 새로운 블록의 속성에 의해 영향을받을 수 없다. 따라서 이러한 유형의 합의는 사전 계산 공격에 내성이 있습니다.


<p><small>This demo page has been used from <a href="http://jasonm23.github.io/markdown-css-themes/" target="_blank">http://jasonm23.github.io/markdown-css-themes/</a>.</small></p>

<h1>A First Level Header</h1>

<h2>A Second Level Header</h2>

<h3>A Third Level Header</h3>

<h4>A Fourth Level Header</h4>

<h5>A Fifth Level Header</h5>

<h6>A Sixed Level Header</h6>

<p>Now is the time for all good men to come to
the aid of their country. This is just a
regular paragraph.</p>

<p>The quick brown fox jumped over the lazy
dog&rsquo;s back.</p>

<hr />

<h3>Header 3</h3>

<blockquote><p>This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</p>

<p>Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
id sem consectetuer libero luctus adipiscing.</p>

<h2>This is an H2 in a blockquote</h2>

<p>This is the first level of quoting.</p>

<blockquote><p>This is nested blockquote.</p></blockquote>

<p>Back to the first level.</p></blockquote>

<p>Some of these words <em>are emphasized</em>.
Some of these words <em>are emphasized also</em>.</p>

<p>Use two asterisks for <strong>strong emphasis</strong>.
Or, if you prefer, <strong>use two underscores instead</strong>.</p>

<ul>
<li>Candy.</li>
<li>Gum.</li>
<li>Booze.</li>
<li>Red</li>
<li>Green</li>
<li><p>Blue</p></li>
<li><p>A list item.</p></li>
</ul>


<p>With multiple paragraphs.</p>

<ul>
<li><p>Another item in the list.</p></li>
<li><p>This is a list item with two paragraphs. Lorem ipsum dolor
sit amet, consectetuer adipiscing elit. Aliquam hendrerit
mi posuere lectus.</p></li>
</ul>


<p>Vestibulum enim wisi, viverra nec, fringilla in, laoreet
vitae, risus. Donec sit amet nisl. Aliquam semper ipsum
sit amet velit.*   Suspendisse id sem consectetuer libero luctus adipiscing.</p>

<ul>
<li>This is a list item with two paragraphs.</li>
</ul>

ㅇㅁㄴㅇㄹ
<p>This is the second paragraph in the list item. You&rsquo;re
only required to indent the first line. Lorem ipsum dolor
sit amet, consectetuer adipiscing elit.</p>

<ul>
<li><p>Another item in the same list.</p></li>
<li><p>A list item with a bit of <code>code</code> inline.</p></li>
<li><p>A list item with a blockquote:</p>

<blockquote><p>This is a blockquote
inside a list item.</p></blockquote></li>
</ul>


<p>Here is an example of a pre code block</p>

<pre><code>tell application "Foo"
    beep
end tell
</code></pre>

<p>This is an <a href="#">example link</a>.</p>

<p>I start my morning with a cup of coffee and
<a href="http://www.nytimes.com/">The New York Times</a>.</p>

### Code snippet

{% highlight python %}
if __name__ =='__main__':
    img_thread = threading.Thread(target=downloadWallpaper)
    img_thread.start()
    st = '\rDownloading Image'
    current = 1
    while img_thread.is_alive():
        sys.stdout.write(st+'.'*((current)%5))
        current=current+1
        time.sleep(0.3)
    img_thread.join()
    print('\nImage of the day downloaded.')
{% endhighlight %}

-->